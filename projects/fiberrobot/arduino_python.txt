// There is an option to have an LED which shows if the program
// is paused / unpaused. You must uncomment 4 lines: 1 in SETUP,
// 2 in the CHECKPAUSE method, and 1 under PINS in the variable declaration

#include <Servo.h>

// Servos
// we use the notation that a CLAMP is stationary, while a GRIP moves (is attached to an actuator)
Servo grip1, grip2;    // grips are attached to actuators
Servo clamp1, clamp2, clamp3; // clamps are stationary
Servo turnServo, cutWheel, liftWheel;
Servo lActuator1, lActuator2; // lActuator1 pulls the fiber from the spool, lActuator2 pulls the fiber from the cut wheel to the polisher

// incoming data
int inComingFraction[5], inComingData[4]; // arrays for storing incoming data
double lengthToCut = 0;

// pins
int grip1Pin = 4, grip2Pin = 5;
int clamp1Pin = 6, clamp2Pin = 7, clamp3Pin = 8;
int turnPin = 9, liftWheelPin = 10, cutWheelPin = 11;
int actuator1Pin = 12, actuator2Pin = 13; 
int switchPin = 22;          // switch pin
// int ledPin; // uncomment (and give a value) to use pause LED

// servo positions
int clampOpen = 180, clampClosed = 20;   // clamp positions
int liftHome = 105, liftScore = 143, liftBreak = 160;  // lift positions
int cutWheelStop = 90, cutWheelMove = 0;    // cut wheel speeds
int arm1Home = 1000;      // lActuator1 positions
int arm2Home = 1000, arm2Polish = 2000;    // lActuator2 positions
int turnHome = 0, turnAround = 180; // turn servo positions
int numCutRevs = 1;    // number of times the cut wheel rotates 180 degrees

// offsets
double lengthOffset = 25; // calibrates pulling wire off of spool
double polishOffset = 2.16; // distance from blade to end of grip2, in inches
double endPolish = 0.25; // length of fiber sticking out of clamp for polishing, in inches

// feedback actuator
int highPin, lowPin;  // digital pins
int feedbackPin;      // analog pins
double epsilon = 1e-8;

void setup() {
  
  // LED to show if program is paused
  // pinMode(ledPin,OUTPUT);  // uncomment to use pause LED   

  // for position feedback actuator
  //pinMode(highPin, OUTPUT);
  //pinMode(lowPin, OUTPUT);
  //digitalWrite(highPin, HIGH);
  //digitalWrite(lowPin, LOW);  
  
  // attach servos
  lActuator1.attach(actuator1Pin, 1000, 2000);
  lActuator2.attach(actuator2Pin, 1000, 2000);
  clamp1.attach(clamp1Pin);
  clamp2.attach(clamp2Pin);
  clamp3.attach(clamp3Pin);
  grip1.attach(grip1Pin);
  grip2.attach(grip2Pin);
  turnServo.attach(turnPin);
  cutWheel.attach(cutWheelPin);
  liftWheel.attach(liftWheelPin);
  
  // set home positions of servos
  lActuator1.writeMicroseconds(arm1Home); // return to home position
  // moveFeedbackAct(arm1Home);
  lActuator2.writeMicroseconds(arm2Home); // return to home position
  clamp1.write(clampClosed);   // close clamp 1
  clamp2.write(clampClosed);   // close clamp 2
  clamp3.write(clampOpen);     // open clamp 3
  grip1.write(clampOpen);       // open grip 1
  grip2.write(clampOpen);      // open grip 2
  turnServo.write(turnHome);
  cutWheel.write(cutWheelStop);
  liftWheel.write(liftHome);
  
  // initialize Serial
  Serial.begin(9600);
  Serial.println("Begin");
  delay(100);

}

void loop()
{
  Serial.println("Enter data: ");
  getIncomingData(); // Receive serial data
  lengthToCut = convertToLength(); // convert serial data to double
  Serial.print("RECEIVED length: ");
  Serial.print(lengthToCut); 
  Serial.print(" number: ");
  Serial.println(inComingData[1]); 
  if (inComingData[0] == 1) { // cut only
    Serial.println("Cutting...");
    for(int i = 0; i < inComingData[1]; i++){ // inComingData[1] = number of wires to cut
      pullWire(lengthToCut);
      checkPause();
    }
  } else if (inComingData[0] == 2) { // polish only
    Serial.println("Polishing...");
    for(int i = 0; i < inComingData[1]; i++){ // inComingData[1] = number of wires to cut
      //polishWire(lengthToCut);
      checkPause();
    }
  } else if (inComingData[0] == 3) { // cut and polish
    Serial.println("Cutting and polishing...");
    for(int i = 0; i < inComingData[1]; i++){ // inComingData[1] = number of wires to cut
      Serial.print("Fiber: ");
      Serial.println(i+1);
      pullWire(lengthToCut); // pull required length of wire
      checkPause();
    }
  }
  
  // reset data to zero
  for(int i = 0; i < 5; i++) {
   inComingFraction[i] = 0; 
  }
  for(int i = 0; i < 4; i++) {
   inComingData[i] = 0; 
  }
  Serial.println("Done.");
}

// collect incoming serial data
// incoming serial data is placed in two arrays
// inComingData[0] = action (0 = do nothing, 1 = cut, 2 = polish, 3 = both)
// inComingData[1] = number of fibers
// inComingData[2] = length, integer part
// inComingData[3] = numbers of digits in fractional part of length
// inComingFraction = length, digits in fractional part of length
void getIncomingData()
{
  int i = 0, j = 0, dataFlag = 1;
  while (dataFlag == 1)
  {
    if(Serial.available() > 0) {    

      if(j < 4){
        inComingData[j] = Serial.read();
        //Serial.print(inComingData[j]);
        j++;
      } 

      if(i < inComingData[3] - 1 && j > 1) {  
        inComingFraction[i] = Serial.read();
        if(i == (inComingData[3]-2)){
          dataFlag--;
         } 
         i++;
       }     
     }   
  }  
} 

// Create double point number for length of fiber
// from serial input, returns lengthInInches, 
// takes inComingFraction and inComingFraction
double convertToLength()
{
  double lengthInInches = inComingData[2];
  for(int j = 1; j < 3; j++){
    lengthInInches = lengthInInches + inComingFraction[j]*pow(10,-j);
  }
  return lengthInInches;
}

// pull fiber
// desiredLength is in inches
void pullWire(double cutLength)
{
  int polishLength = cutLength;
  while(cutLength > 1){
      // pull 1 inch at a time, from spool, until remaining 
      // length to pull is less than 1 inch
      grip1.write(20); // close grip
      clamp1.write(clampOpen); //open clamp 1
      clamp2.write(clampOpen); //open clamp 2
      clamp3.write(clampOpen); //open clamp 3
      delay(500);
      lActuator1.writeMicroseconds(inchToMMActuator1(1)); // pull wire to length
      // moveFeedbackAct(inchToMM(1));
      delay(2000);
      clamp1.write(clampClosed); // close clamp 1
      clamp2.write(clampClosed); //close clamp 2
      clamp3.write(8); // close clamp 3
      grip1.write(clampOpen); // open grip
      delay(500);
      lActuator1.writeMicroseconds(arm1Home); // retract actuator
      // moveFeedbackAct(arm1Home);
      delay(2000);
      cutLength = cutLength - 1;  
  }
  if(cutLength > 0) {
     // pull remaining length from spool
     grip1.write(20); // close grip
     clamp1.write(clampOpen); //open clamp 1
     clamp2.write(clampOpen); //open clamp 2
     clamp3.write(clampOpen); //open clamp 3
     delay(500);
     lActuator1.writeMicroseconds((int)inchToMMActuator1(cutLength)); // pull fiber to length
     // moveFeedbackAct(inchToMMActuator1(cutLength));
     delay(2000);
     clamp1.write(clampClosed); // close clamp 1
     clamp2.write(clampClosed); //close clamp 2
     clamp3.write(8); // close clamp 3
     delay(1000);
     liftWheel.write(liftScore); // lift to score
     delay(100);
     scoreAndCut();  // score and cut
     delay(100);
     liftWheel.write(liftBreak);  // lift to break
     delay(100);
     liftWheel.write(liftHome);  // lift in home position
     grip1.write(clampOpen); // open grip
     delay(100);
     lActuator1.writeMicroseconds(arm1Home); // retract actuator1
     // moveFeedbackAct(arm1Home);
     
     // pull poslish wire
     clamp3.write(clampClosed);       // close clamp3 
     lActuator2.writeMicroseconds((int)inchToMMActuator2(polishLength - polishOffset - endPolish));   // move actuator2 to end of fiber
     delay(2500);
     grip2.write(clampClosed);      // close grip2
     clamp3.write(clampOpen);       // open clamp3 
     delay(500);
     lActuator2.writeMicroseconds(arm2Polish);  // move actuator2 to polisher
     delay(5000);
     // polish();
     turnServo.write(turnAround);        // rotate turnServo servo 180 degrees
     lActuator2.write(arm2Home);            // move actuator2 home
     delay(5000);
     clamp3.write(clampClosed);     // close clamp3
     grip2.write(clampOpen);      // open grip2
     delay(500);
     lActuator2.writeMicroseconds((int)inchToMMActuator2(polishLength - endPolish));    // move actuator2 to opposite end of fiber
     delay(2500);
     grip2.write(clampClosed);      // close grip2
     clamp3.write(clampOpen);       // open clamp3 
     delay(500);
     lActuator2.writeMicroseconds(arm2Polish);  // move act2 to polisher
     delay(5000);
     // polish();
     turnServo.write(turnHome);    // rotate turnServo to home position
     lActuator2.writeMicroseconds(arm2Home);   // return actuator2 home
     delay(5000);
     grip2.write(clampOpen);       // open grip2
  }
}

// cut the fiber
// move cut wheel, count number of rotations by reading switch
void scoreAndCut(){
  int cutCounter = 0, cutFlag = 1;
  cutWheel.write(cutWheelMove);
  while(cutFlag == 1){
    delay(1000);
    while (digitalRead(switchPin) == HIGH) {
      delay(1); 
    }
    cutCounter++;
    if (cutCounter == numCutRevs){
      cutFlag = 0;
    }
  }
  cutWheel.write(cutWheelStop);
}

// for the pull fiber actuator, lActuator1
// convert inches to mm (1 inch = 25.4 mm) 
// convert mm to PWM (1000 PWM = 100 mm)
// then shift PWM from 0-1000 to 1000-2000 (add 1000)
// add calibration offset (lengthOffset)
// inch * (25.4 mm / 1 in) * (1000 PWM / 100 mm) + 1000 + lengthOffset
double inchToMMActuator1(double inches){
    return inches * 508 + 1000 + lengthOffset; 
    // an offset of 25 was added to the above number
    // to calibrate the arms movement
}  

// for the polish fiber actuator, lActuator2
// convert inches to mm (1 inch = 25.4 mm)
// convert mm to PWM (1000 PWM = 50 mm)
// then shift PWM from 0-1000 to 1000-2000 (add 1000)
// add calibration offset (lengthOffset)
// inch * (25.4 mm / 1 in) * (1000 PWM / 50 mm) + 1000 + lengthOffset
double inchToMMActuator2(double inches){
    return inches * 254 + 1000 + lengthOffset; 
    // an offset was added to the above number
    // to calibrate the arms movement
}  

// pause the program 
// user input 80 = 'P'
// 85 = 'U'
void checkPause(){
  int pauseFlag = 1;
  if(Serial.read() == 80){
    Serial.println("Paused...");
    while(pauseFlag == 1){
      // digitalWrite(ledPin,HIGH); // uncomment to use pause LED
      if(Serial.available() > 0){
        if(Serial.read() == 85){
          pauseFlag = 0;
          Serial.println("Unpaused.");
          // digitalWrite(ledPin,LOW);  // uncomment to use pause LED
        }
      }
    }
  }  
}


// Uses voltage feedback to determine position of actuator
// Voltage between 0-5 V, position between 0-50 mm
// analogRead returns value between 0-1023
// Assumes actuator can receive a PWM signal
// with 0 retracting arm at max speed
// and 255 extending arm at max speed
void moveFeedbackAct(double desiredPosition){
  double currentPosition = 10*(5/1024)*analogRead(feedbackPin);
  double moveValue;
  while(abs(desiredPosition - currentPosition) > epsilon){
    moveValue = 2.55*(desiredPosition - currentPosition) + 127.5; 
    // move value is a PWM signal between 0 and 255
    // (255/100) * error + 127.5
    // error is between -50 and 50 in mm
    analogWrite(actuator2Pin, (int)moveValue);
    currentPosition = 10*(5/1024)*analogRead(feedbackPin);
  }
}
